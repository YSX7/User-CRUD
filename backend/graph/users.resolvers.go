package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"log"
	"strconv"

	"vuegolang/dbmodels"
	"vuegolang/graph/model"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

func parseDbData(dbusers []dbmodels.User) (outputData []*model.User) {
	outputData = make([]*model.User, len(dbusers))

	for i, user := range dbusers {
		id := strconv.Itoa(user.ID)
		outputData[i] = &model.User{id, user.Login, model.Role(user.Role)}
	}

	return
}

// UserNew is the resolver for the userNew field.
func (r *mutationResolver) UserNew(ctx context.Context, users []*model.NewUserInput) ([]*model.User, error) {
	var (
		usersData = make([]dbmodels.User, len(users))
	)
	for i, v := range users {
		usersData[i] = dbmodels.User{Login: v.Login, Password: "test", Role: v.Role.String()}
	}

	_, err := r.Db.NewInsert().Model(&usersData).Exec(ctx)
	if err != nil {
		log.Printf("DB new user insert: %v", err)
		return nil, &gqlerror.Error{Message: "Ошибка добавления"}
	}

	outputData := parseDbData(usersData)

	return outputData, nil
}

// UserUpdate is the resolver for the userUpdate field.
func (r *mutationResolver) UserUpdate(ctx context.Context, users []*model.UpdateUserInput) ([]*model.User, error) {
	var (
		usersData = make(
			[]dbmodels.User, len(users),
		)
	)

	for i, v := range users {
		id, _ := strconv.Atoi(v.ID)
		usersData[i] = dbmodels.User{ID: id, Login: v.Login, Role: v.Role.String()}
	}

	_, err := r.Db.NewUpdate().
		Model(&usersData).
		Column("login", "role").
		Bulk().
		Exec(ctx)
	if err != nil {
		log.Printf("DB update: %v", err)
		return nil, &gqlerror.Error{Message: "Ошибка обновления"}
	}

	outputData := parseDbData(usersData)

	return outputData, nil
}

// UserDelete is the resolver for the userDelete field.
func (r *mutationResolver) UserDelete(ctx context.Context, users []string) (*int, error) {
	var (
		usersData = make(
			[]dbmodels.User, len(users),
		)
	)

	for i, v := range users {
		id, _ := strconv.Atoi(v)
		usersData[i] = dbmodels.User{ID: id}
	}

	res, err := r.Db.NewDelete().Model(&usersData).WherePK().Exec(ctx)
	if err != nil {
		log.Printf("DB update: %v", err)
		return nil, &gqlerror.Error{Message: "Ошибка обновления"}
	}

	rowsAffected, _ := res.RowsAffected()
	intRowsAffected := int(rowsAffected)

	return &intRowsAffected, nil
}
