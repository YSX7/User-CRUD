package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"fmt"
	"log"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"vuegolang/dbmodels"
	"vuegolang/graph/model"
)

// UserNew is the resolver for the userNew field.
func (r *mutationResolver) UserNew(ctx context.Context, users []*model.NewUserInput) ([]*model.User, error) {
	var (
		usersData  = make([]dbmodels.User, len(users))
		outputData = make([]*model.User, len(users))
	)
	for i, v := range users {
		usersData[i] = dbmodels.User{Login: v.Login, Password: "test", Role: v.Role.String()}
	}

	_, err := r.Db.NewInsert().Model(&usersData).Exec(ctx)
	if err != nil {
		log.Printf("DB new user insert error: %v", err)
		return nil, &gqlerror.Error{Message: "Ошибка добавления"}
	}

	for i, user := range usersData {
		outputData[i] = &model.User{user.ID, user.Login, model.Role(user.Role)}
	}

	return outputData, nil
}

// UserUpdate is the resolver for the userUpdate field.
func (r *mutationResolver) UserUpdate(ctx context.Context, users []*model.UpdateUserInput) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: UserUpdate - userUpdate"))
}

// UserDelete is the resolver for the userDelete field.
func (r *mutationResolver) UserDelete(ctx context.Context, users []string) ([]string, error) {
	panic(fmt.Errorf("not implemented: UserDelete - userDelete"))
}
